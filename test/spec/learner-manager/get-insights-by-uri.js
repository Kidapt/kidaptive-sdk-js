'use strict';
import TestConstants from './test-constants';
import TestUtils from '../test-utils';
import Constants from '../../../src/constants';
import LearnerManager from '../../../src/learner-manager';
import Should from 'should';
import Sinon from 'sinon';

export default () => {

    describe('getInsightsByUri', () => {
        let server;

        before(() => {
            server = Sinon.fakeServer.create();
        });

        beforeEach(() => {
            server.resetHistory();
            server.respondImmediately = true;
            server.respondWith(TestConstants.defaultServerResponse);
            TestUtils.resetStateAndCache();
            TestUtils.setState(TestConstants.defaultState);
        });

        after(() => {
            server.restore();
            TestUtils.resetStateAndCache();
        });

        describe('Validate', () => {

            beforeEach(() => {
                server.respondWith([200, {
                    'Content-Type': 'application/json'
                }, '"ok"']);
            });

            describe('insightUri is required and must be a string', () => {
                const testFunction = parameter => {
                    return LearnerManager.getInsightsByUri(parameter);
                };
                TestUtils.validatePromiseProperty(testFunction, 'string', true);
            });

            describe('minTimestamp must be an integer that is at least 0 if defined', () => {
                const testFunction = parameter => {
                    return LearnerManager.getInsightsByUri('insightUri', parameter);
                };
                TestUtils.validatePromiseProperty(testFunction, 'number', false, [0, 1, 1000000000], [-1, 1.5]);
            });

            describe('maxTimestamp must be a positive integer if defined', () => {
                const testFunction = parameter => {
                    return LearnerManager.getInsightsByUri('insightUri', null, parameter);
                };
                TestUtils.validatePromiseProperty(testFunction, 'number', false, [1, 1000000000], [-1, 0, 1.5]);
            });
            describe('maxTimestamp must be greater than minTimestamp', () => {
                const testFunction = parameter => {
                    return LearnerManager.getInsightsByUri('insightUri', 1000, parameter);
                };
                TestUtils.validatePromiseProperty(testFunction, 'number', false, [1001, 10000], [999, 1000]);
            });
        }); // END Validate

        it('Correct API request sent', () => {
            const learnerId = 100;
            TestUtils.setState({
                learnerId
            });
            server.respondWith([200, {
                'Content-Type': 'application/json'
            }, '"ok"']);
            return Should(LearnerManager.getInsightsByUri('/mock/insight/uri', 1000, 2000)).resolved().then(response => {
                Should(server.requests).length(1);
                const request = server.requests[0];
                Should(request.method).equal('GET');
                Should(TestUtils.parseUrl(request.url).url).endWith(Constants.ENDPOINT.INSIGHT);
                Should(TestUtils.parseUrl(request.url).query).equal('learnerId=100&uri=%2Fmock%2Finsight%2Furi&minDateCreated=1000&maxDateCreated=2000');
                Should(request.requestBody).equal(null);
                Should(response).equal('ok');
            });
        }); //END Correct API request sent

        it('Response handled correctly', () => {
            const learnerId = 100;
            TestUtils.setState({
                learnerId
            });
            server.respondWith([200, {
                'Content-Type': 'application/json'
            }, '"ok"']);
            return Should(LearnerManager.getInsightsByUri('/mock/insight/uri')).resolved().then(result => {
                Should(result).deepEqual('ok');
            });
        }); //END Response handled correctly

        it('API error results in promise rejection', () => {
            const learnerId = 100;
            TestUtils.setState({
                learnerId
            });
            server.respondWith([500, {}, '']);
            return Should(LearnerManager.getInsightsByUri('/mock/insight/uri')).rejected();
        }); //END API error results in promise rejection

        it('No learner returns undefined with no server request', () => {
            return Should(LearnerManager.getInsightsByUri('/mock/insight/uri')).resolved().then(result => {
                Should(server.requests).length(0);
                Should(result).equal(undefined);
            });
        }); //END No learner returns undefined with no server request

        describe('Autogenerated Range', () => {
            it('No timestamps provided defaults to minDateCreated=0 and and maxDateCreated=now', () => {
                TestUtils.setState({learnerId: 100});
                server.respondWith([200, {'Content-Type': 'application/json'}, '"ok"']);
                let now = Date.now();
                return Should(LearnerManager.getInsightsByUri('some_uri')).resolved().then(response => {
                    Should(server.requests).length(1);
                    const request = server.requests[0];
                    Should(request.method).equal('GET');
                    Should(TestUtils.parseUrl(request.url).url).endWith(Constants.ENDPOINT.INSIGHT);
                    let query = TestUtils.parseUrl(request.url).query;
                    let expectedQueryPrefix = 'learnerId=100&uri=some_uri&minDateCreated=0&maxDateCreated=';
                    Should(query).startWith(expectedQueryPrefix);
                    let queryEnd = query.substring(expectedQueryPrefix.length);
                    let maxTimestamp = parseInt(queryEnd, 10);
                    Should(Math.abs(now - maxTimestamp)).lessThan(1000); // 1 sec tolerance
                });
            });
        });

    }); //END getInsightsByUri

}; //END export